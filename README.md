# seesea

A (partial) C compiler targeting LLVM IR or aarch64 assembly. 

This is not an optimising compiler, but it's certainly a compiling compiler, 
and that ought to be enough for anybody. Besides, LLVM can fix anything pathological on its own.

## Supported Features

- float/double, unsigned int/long
  - `+ - * / % >= <= > < ==`
- variables, pointers (`&a, *b, c[2]`)
- if/else, loops (for, while, do while), break/continue
- functions
- structs, typedefs

See examples in `tests.rs`.

## Limitations 

- Pointers are assumed to be 64 bits. 
- Maybe features are implemented as syntax de-sugaring to other features which may have unexpected runtime performance characteristics.
- No debug info is emitted. 
- This does not include a preprocessor, so it depends on something else for macros, includes, etc. 

### Aarch64 Backend Specific 

- Can only target macOS because they use a slightly different calling convention.
- Outputs text, not binary executables, so it still depends on an assembler and linker. 
- Not optimised. Function calls and phi nodes generate unnecessary move instructions. 

## TODO

switch, statically allocated arrays, goto, break, continue, enums, pass structs by value, 
signed values, correct char size, bitwise ops, 
and/or short-circuiting, struct/array init literals, write variadic functions, 
global/static variables, function pointers. 
 
- cranelift backend (don't bother with ssa)
- brainfuck backend (no libc, just `puts` & `gets`)
- CLI
- better test system 
  - use real linker instead of inline asm macro 
  - print which backend each works on separately 
  - steal tests from a real c compiler
- compile to wasm and make demo ui

## Libraries

- The lexer (converting source code to a stream of tokens) is generated by [Logos](https://crates.io/crates/logos). 
  - all backends
- LLVM (with the llvm-sys rust bindings).
  - llvm backend only
